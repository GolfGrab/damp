/* tslint:disable */
/* eslint-disable */
/**
 * NestJS Prisma Example
 * The NestJS Prisma Example API description
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'channelType': AccountChannelTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'channelToken': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'verifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updatedAt': string;
}

export const AccountChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;

export type AccountChannelTypeEnum = typeof AccountChannelTypeEnum[keyof typeof AccountChannelTypeEnum];

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Application
     */
    'isEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updatedByUserId': string;
}
/**
 * 
 * @export
 * @interface ApplicationWithApiKey
 */
export interface ApplicationWithApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'apiKey': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationWithApiKey
     */
    'isEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithApiKey
     */
    'updatedByUserId': string;
}
/**
 * 
 * @export
 * @interface CompiledMessage
 */
export interface CompiledMessage {
    /**
     * 
     * @type {string}
     * @memberof CompiledMessage
     */
    'templateId': string;
    /**
     * 
     * @type {string}
     * @memberof CompiledMessage
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CompiledMessage
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof CompiledMessage
     */
    'notificationId': number;
    /**
     * 
     * @type {string}
     * @memberof CompiledMessage
     */
    'messageType': string;
    /**
     * 
     * @type {string}
     * @memberof CompiledMessage
     */
    'compiledMessage': string;
}
/**
 * 
 * @export
 * @interface CreateApplicationDto
 */
export interface CreateApplicationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationDto
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationDto
     */
    'updatedByUserId': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationCategoryDto
 */
export interface CreateNotificationCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationCategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationCategoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationCategoryDto
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationCategoryDto
     */
    'updatedByUserId': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationDto
 */
export interface CreateNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationDto
     */
    'templateId': string;
    /**
     * 
     * @type {object}
     * @memberof CreateNotificationDto
     */
    'templateData': object;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationDto
     */
    'notificationCategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationDto
     */
    'priority': CreateNotificationDtoPriorityEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateNotificationDto
     */
    'recipientIds': Array<string>;
}

export const CreateNotificationDtoPriorityEnum = {
    Low: 'LOW',
    Medium: 'MEDIUM',
    High: 'HIGH'
} as const;

export type CreateNotificationDtoPriorityEnum = typeof CreateNotificationDtoPriorityEnum[keyof typeof CreateNotificationDtoPriorityEnum];

/**
 * 
 * @export
 * @interface CreateTemplateDto
 */
export interface CreateTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTemplateDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CreateTemplateDto
     */
    'template': object;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetPreviewTemplateDto
 */
export interface GetPreviewTemplateDto {
    /**
     * 
     * @type {object}
     * @memberof GetPreviewTemplateDto
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'notificationCategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'templateId': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'templateData': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'priority': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface NotificationCategory
 */
export interface NotificationCategory {
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCategory
     */
    'updatedByUserId': string;
}
/**
 * 
 * @export
 * @interface NotificationTask
 */
export interface NotificationTask {
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'templateId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'priority': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'channelType': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof NotificationTask
     */
    'notificationId': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'messageType': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'sentStatus': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'sentTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationTask
     */
    'failedTimestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationTask
     */
    'retryCount': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationTask
     */
    'retryLimit': number;
}
/**
 * 
 * @export
 * @interface OutputNotificationWithCompiledMessageAndNotificationTaskDto
 */
export interface OutputNotificationWithCompiledMessageAndNotificationTaskDto {
    /**
     * 
     * @type {PickTypeClass}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'notificationCategory': PickTypeClass;
    /**
     * 
     * @type {PickTypeClass}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'application': PickTypeClass;
    /**
     * 
     * @type {Array<NotificationTask>}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'notificationTasks': Array<NotificationTask>;
    /**
     * 
     * @type {Array<CompiledMessage>}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'compiledMessages': Array<CompiledMessage>;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'notificationCategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'templateId': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'templateData': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'priority': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof OutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto
 */
export interface PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto {
    /**
     * 
     * @type {Array<OutputNotificationWithCompiledMessageAndNotificationTaskDto>}
     * @memberof PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'data'?: Array<OutputNotificationWithCompiledMessageAndNotificationTaskDto>;
    /**
     * 
     * @type {PaginatedResponseOfTemplateAllOfMeta}
     * @memberof PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto
     */
    'meta'?: PaginatedResponseOfTemplateAllOfMeta;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfTemplate
 */
export interface PaginatedResponseOfTemplate {
    /**
     * 
     * @type {Array<Template>}
     * @memberof PaginatedResponseOfTemplate
     */
    'data'?: Array<Template>;
    /**
     * 
     * @type {PaginatedResponseOfTemplateAllOfMeta}
     * @memberof PaginatedResponseOfTemplate
     */
    'meta'?: PaginatedResponseOfTemplateAllOfMeta;
}
/**
 * 
 * @export
 * @interface PaginatedResponseOfTemplateAllOfMeta
 */
export interface PaginatedResponseOfTemplateAllOfMeta {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'lastPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'currentPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'prev'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponseOfTemplateAllOfMeta
     */
    'next'?: number | null;
}
/**
 * 
 * @export
 * @interface PickTypeClass
 */
export interface PickTypeClass {
    /**
     * 
     * @type {string}
     * @memberof PickTypeClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'template': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'updatedByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'deletedByUserId': string | null;
}
/**
 * 
 * @export
 * @interface UpdateApplicationDto
 */
export interface UpdateApplicationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationDto
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationDto
     */
    'updatedByUserId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateNotificationCategoryDto
 */
export interface UpdateNotificationCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationCategoryDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationCategoryDto
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationCategoryDto
     */
    'updatedByUserId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTemplateDto
 */
export interface UpdateTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTemplateDto
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateTemplateDto
     */
    'template'?: object;
}
/**
 * 
 * @export
 * @interface UpsertAccountDto
 */
export interface UpsertAccountDto {
    /**
     * 
     * @type {string}
     * @memberof UpsertAccountDto
     */
    'channelToken': string;
}
/**
 * 
 * @export
 * @interface UpsertUserPreferenceDto
 */
export interface UpsertUserPreferenceDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpsertUserPreferenceDto
     */
    'isPreferred': boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'notificationCategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'channelType': UserPreferenceChannelTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    'isPreferred': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    'updatedAt': string;
}

export const UserPreferenceChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;

export type UserPreferenceChannelTypeEnum = typeof UserPreferenceChannelTypeEnum[keyof typeof UserPreferenceChannelTypeEnum];

/**
 * 
 * @export
 * @interface VerifyUserDto
 */
export interface VerifyUserDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyUserDto
     */
    'otpCode': string;
}

/**
 * ApplicationModuleApi - axios parameter creator
 * @export
 */
export const ApplicationModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Applications
         * @summary 
         * @param {CreateApplicationDto} createApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerCreateApplication: async (createApplicationDto: CreateApplicationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationDto' is not null or undefined
            assertParamExists('mApplicationControllerCreateApplication', 'createApplicationDto', createApplicationDto)
            const localVarPath = `/m-application/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Notification Categories
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationCategoryDto} createNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerCreateNotificationCategory: async (applicationId: string, createNotificationCategoryDto: CreateNotificationCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mApplicationControllerCreateNotificationCategory', 'applicationId', applicationId)
            // verify required parameter 'createNotificationCategoryDto' is not null or undefined
            assertParamExists('mApplicationControllerCreateNotificationCategory', 'createNotificationCategoryDto', createNotificationCategoryDto)
            const localVarPath = `/m-application/applications/{applicationId}/notification-categories`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllApplications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/m-application/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} createdByUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllApplicationsByUserId: async (createdByUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createdByUserId' is not null or undefined
            assertParamExists('mApplicationControllerFindAllApplicationsByUserId', 'createdByUserId', createdByUserId)
            const localVarPath = `/m-application/users/{createdByUserId}/applications`
                .replace(`{${"createdByUserId"}}`, encodeURIComponent(String(createdByUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllNotificationCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/m-application/notification-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllNotificationCategoriesByApplicationId: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mApplicationControllerFindAllNotificationCategoriesByApplicationId', 'applicationId', applicationId)
            const localVarPath = `/m-application/applications/{applicationId}/notification-categories`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindOneApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mApplicationControllerFindOneApplication', 'applicationId', applicationId)
            const localVarPath = `/m-application/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindOneNotificationCategory: async (notificationCategoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCategoryId' is not null or undefined
            assertParamExists('mApplicationControllerFindOneNotificationCategory', 'notificationCategoryId', notificationCategoryId)
            const localVarPath = `/m-application/notification-categories/{notificationCategoryId}`
                .replace(`{${"notificationCategoryId"}}`, encodeURIComponent(String(notificationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerRotateApiKey: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mApplicationControllerRotateApiKey', 'applicationId', applicationId)
            const localVarPath = `/m-application/applications/{applicationId}/rotate-api-key`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationDto} updateApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerUpdateApplication: async (applicationId: string, updateApplicationDto: UpdateApplicationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mApplicationControllerUpdateApplication', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationDto' is not null or undefined
            assertParamExists('mApplicationControllerUpdateApplication', 'updateApplicationDto', updateApplicationDto)
            const localVarPath = `/m-application/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {UpdateNotificationCategoryDto} updateNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerUpdateNotificationCategory: async (notificationCategoryId: string, updateNotificationCategoryDto: UpdateNotificationCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCategoryId' is not null or undefined
            assertParamExists('mApplicationControllerUpdateNotificationCategory', 'notificationCategoryId', notificationCategoryId)
            // verify required parameter 'updateNotificationCategoryDto' is not null or undefined
            assertParamExists('mApplicationControllerUpdateNotificationCategory', 'updateNotificationCategoryDto', updateNotificationCategoryDto)
            const localVarPath = `/m-application/notification-categories/{notificationCategoryId}`
                .replace(`{${"notificationCategoryId"}}`, encodeURIComponent(String(notificationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationModuleApi - functional programming interface
 * @export
 */
export const ApplicationModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Applications
         * @summary 
         * @param {CreateApplicationDto} createApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerCreateApplication(createApplicationDto: CreateApplicationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationWithApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerCreateApplication(createApplicationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerCreateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Notification Categories
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationCategoryDto} createNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerCreateNotificationCategory(applicationId: string, createNotificationCategoryDto: CreateNotificationCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerCreateNotificationCategory(applicationId, createNotificationCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerCreateNotificationCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindAllApplications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindAllApplications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindAllApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} createdByUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindAllApplicationsByUserId(createdByUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindAllApplicationsByUserId(createdByUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindAllApplicationsByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindAllNotificationCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindAllNotificationCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindAllNotificationCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindAllNotificationCategoriesByApplicationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindOneApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindOneApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindOneApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerFindOneNotificationCategory(notificationCategoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerFindOneNotificationCategory(notificationCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerFindOneNotificationCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerRotateApiKey(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationWithApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerRotateApiKey(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerRotateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationDto} updateApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerUpdateApplication(applicationId: string, updateApplicationDto: UpdateApplicationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerUpdateApplication(applicationId, updateApplicationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerUpdateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {UpdateNotificationCategoryDto} updateNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mApplicationControllerUpdateNotificationCategory(notificationCategoryId: string, updateNotificationCategoryDto: UpdateNotificationCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mApplicationControllerUpdateNotificationCategory(notificationCategoryId, updateNotificationCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationModuleApi.mApplicationControllerUpdateNotificationCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationModuleApi - factory interface
 * @export
 */
export const ApplicationModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationModuleApiFp(configuration)
    return {
        /**
         * Applications
         * @summary 
         * @param {CreateApplicationDto} createApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerCreateApplication(createApplicationDto: CreateApplicationDto, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationWithApiKey> {
            return localVarFp.mApplicationControllerCreateApplication(createApplicationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Notification Categories
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationCategoryDto} createNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerCreateNotificationCategory(applicationId: string, createNotificationCategoryDto: CreateNotificationCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationCategory> {
            return localVarFp.mApplicationControllerCreateNotificationCategory(applicationId, createNotificationCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllApplications(options?: RawAxiosRequestConfig): AxiosPromise<Array<Application>> {
            return localVarFp.mApplicationControllerFindAllApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} createdByUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllApplicationsByUserId(createdByUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Application>> {
            return localVarFp.mApplicationControllerFindAllApplicationsByUserId(createdByUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllNotificationCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationCategory>> {
            return localVarFp.mApplicationControllerFindAllNotificationCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationCategory>> {
            return localVarFp.mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindOneApplication(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.mApplicationControllerFindOneApplication(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerFindOneNotificationCategory(notificationCategoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationCategory> {
            return localVarFp.mApplicationControllerFindOneNotificationCategory(notificationCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerRotateApiKey(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationWithApiKey> {
            return localVarFp.mApplicationControllerRotateApiKey(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateApplicationDto} updateApplicationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerUpdateApplication(applicationId: string, updateApplicationDto: UpdateApplicationDto, options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.mApplicationControllerUpdateApplication(applicationId, updateApplicationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {UpdateNotificationCategoryDto} updateNotificationCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mApplicationControllerUpdateNotificationCategory(notificationCategoryId: string, updateNotificationCategoryDto: UpdateNotificationCategoryDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationCategory> {
            return localVarFp.mApplicationControllerUpdateNotificationCategory(notificationCategoryId, updateNotificationCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationModuleApi - object-oriented interface
 * @export
 * @class ApplicationModuleApi
 * @extends {BaseAPI}
 */
export class ApplicationModuleApi extends BaseAPI {
    /**
     * Applications
     * @summary 
     * @param {CreateApplicationDto} createApplicationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerCreateApplication(createApplicationDto: CreateApplicationDto, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerCreateApplication(createApplicationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Notification Categories
     * @summary 
     * @param {string} applicationId 
     * @param {CreateNotificationCategoryDto} createNotificationCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerCreateNotificationCategory(applicationId: string, createNotificationCategoryDto: CreateNotificationCategoryDto, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerCreateNotificationCategory(applicationId, createNotificationCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindAllApplications(options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindAllApplications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} createdByUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindAllApplicationsByUserId(createdByUserId: string, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindAllApplicationsByUserId(createdByUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindAllNotificationCategories(options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindAllNotificationCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindAllNotificationCategoriesByApplicationId(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindOneApplication(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindOneApplication(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} notificationCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerFindOneNotificationCategory(notificationCategoryId: string, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerFindOneNotificationCategory(notificationCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerRotateApiKey(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerRotateApiKey(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {UpdateApplicationDto} updateApplicationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerUpdateApplication(applicationId: string, updateApplicationDto: UpdateApplicationDto, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerUpdateApplication(applicationId, updateApplicationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} notificationCategoryId 
     * @param {UpdateNotificationCategoryDto} updateNotificationCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationModuleApi
     */
    public mApplicationControllerUpdateNotificationCategory(notificationCategoryId: string, updateNotificationCategoryDto: UpdateNotificationCategoryDto, options?: RawAxiosRequestConfig) {
        return ApplicationModuleApiFp(this.configuration).mApplicationControllerUpdateNotificationCategory(notificationCategoryId, updateNotificationCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerMe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MainModuleApi - axios parameter creator
 * @export
 */
export const MainModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetSwaggerStopLight: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/docs-stop-light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MainModuleApi - functional programming interface
 * @export
 */
export const MainModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MainModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainModuleApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetSwaggerStopLight(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetSwaggerStopLight(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainModuleApi.appControllerGetSwaggerStopLight']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MainModuleApi - factory interface
 * @export
 */
export const MainModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MainModuleApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetSwaggerStopLight(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.appControllerGetSwaggerStopLight(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MainModuleApi - object-oriented interface
 * @export
 * @class MainModuleApi
 * @extends {BaseAPI}
 */
export class MainModuleApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainModuleApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return MainModuleApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainModuleApi
     */
    public appControllerGetSwaggerStopLight(options?: RawAxiosRequestConfig) {
        return MainModuleApiFp(this.configuration).appControllerGetSwaggerStopLight(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationModuleApi - axios parameter creator
 * @export
 */
export const NotificationModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Notifications
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationDto} createNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerCreateNotification: async (applicationId: string, createNotificationDto: CreateNotificationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mNotificationControllerCreateNotification', 'applicationId', applicationId)
            // verify required parameter 'createNotificationDto' is not null or undefined
            assertParamExists('mNotificationControllerCreateNotification', 'createNotificationDto', createNotificationDto)
            const localVarPath = `/m-notification/applications/{applicationId}/notifications`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Api_Key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Templates
         * @summary 
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerCreateTemplate: async (createTemplateDto: CreateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTemplateDto' is not null or undefined
            assertParamExists('mNotificationControllerCreateTemplate', 'createTemplateDto', createTemplateDto)
            const localVarPath = `/m-notification/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerDeleteTemplate: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('mNotificationControllerDeleteTemplate', 'templateId', templateId)
            const localVarPath = `/m-notification/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/m-notification/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByApplicationId: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('mNotificationControllerFindAllNotificationsByApplicationId', 'applicationId', applicationId)
            const localVarPath = `/m-notification/applications/{applicationId}/notifications`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByNotificationCategoryId: async (notificationCategoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCategoryId' is not null or undefined
            assertParamExists('mNotificationControllerFindAllNotificationsByNotificationCategoryId', 'notificationCategoryId', notificationCategoryId)
            const localVarPath = `/m-notification/notification-categories/{notificationCategoryId}/notifications`
                .replace(`{${"notificationCategoryId"}}`, encodeURIComponent(String(notificationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByTemplateId: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('mNotificationControllerFindAllNotificationsByTemplateId', 'templateId', templateId)
            const localVarPath = `/m-notification/templates/{templateId}/notifications`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [templateName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllTemplatesPaginated: async (page?: number, perPage?: number, templateName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/m-notification/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (templateName !== undefined) {
                localVarQueryParameter['templateName'] = templateName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindOneNotification: async (notificationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('mNotificationControllerFindOneNotification', 'notificationId', notificationId)
            const localVarPath = `/m-notification/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindOneTemplate: async (templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('mNotificationControllerFindOneTemplate', 'templateId', templateId)
            const localVarPath = `/m-notification/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerGetNotificationsForUserById: async (userId: string, notificationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mNotificationControllerGetNotificationsForUserById', 'userId', userId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('mNotificationControllerGetNotificationsForUserById', 'notificationId', notificationId)
            const localVarPath = `/m-notification/users/{userId}/notifications/{notificationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerGetPaginatedNotificationsByUserId: async (userId: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mNotificationControllerGetPaginatedNotificationsByUserId', 'userId', userId)
            const localVarPath = `/m-notification/users/{userId}/notifications`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {MNotificationControllerPreviewTemplateMessageTypeEnum} messageType 
         * @param {GetPreviewTemplateDto} getPreviewTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerPreviewTemplate: async (templateId: string, messageType: MNotificationControllerPreviewTemplateMessageTypeEnum, getPreviewTemplateDto: GetPreviewTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('mNotificationControllerPreviewTemplate', 'templateId', templateId)
            // verify required parameter 'messageType' is not null or undefined
            assertParamExists('mNotificationControllerPreviewTemplate', 'messageType', messageType)
            // verify required parameter 'getPreviewTemplateDto' is not null or undefined
            assertParamExists('mNotificationControllerPreviewTemplate', 'getPreviewTemplateDto', getPreviewTemplateDto)
            const localVarPath = `/m-notification/templates/{templateId}/messageType/{messageType}/preview`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"messageType"}}`, encodeURIComponent(String(messageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPreviewTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerUpdateTemplate: async (templateId: string, updateTemplateDto: UpdateTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('mNotificationControllerUpdateTemplate', 'templateId', templateId)
            // verify required parameter 'updateTemplateDto' is not null or undefined
            assertParamExists('mNotificationControllerUpdateTemplate', 'updateTemplateDto', updateTemplateDto)
            const localVarPath = `/m-notification/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationModuleApi - functional programming interface
 * @export
 */
export const NotificationModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Notifications
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationDto} createNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerCreateNotification(applicationId: string, createNotificationDto: CreateNotificationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerCreateNotification(applicationId, createNotificationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerCreateNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Templates
         * @summary 
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerCreateTemplate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerCreateTemplate(createTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerCreateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerDeleteTemplate(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerDeleteTemplate(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerDeleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindAllNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindAllNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindAllNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindAllNotificationsByApplicationId(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindAllNotificationsByApplicationId(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindAllNotificationsByApplicationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindAllNotificationsByNotificationCategoryId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindAllNotificationsByTemplateId(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindAllNotificationsByTemplateId(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindAllNotificationsByTemplateId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [templateName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindAllTemplatesPaginated(page?: number, perPage?: number, templateName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindAllTemplatesPaginated(page, perPage, templateName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindAllTemplatesPaginated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindOneNotification(notificationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindOneNotification(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindOneNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerFindOneTemplate(templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerFindOneTemplate(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerFindOneTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerGetNotificationsForUserById(userId: string, notificationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutputNotificationWithCompiledMessageAndNotificationTaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerGetNotificationsForUserById(userId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerGetNotificationsForUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerGetPaginatedNotificationsByUserId(userId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerGetPaginatedNotificationsByUserId(userId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerGetPaginatedNotificationsByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {MNotificationControllerPreviewTemplateMessageTypeEnum} messageType 
         * @param {GetPreviewTemplateDto} getPreviewTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerPreviewTemplate(templateId: string, messageType: MNotificationControllerPreviewTemplateMessageTypeEnum, getPreviewTemplateDto: GetPreviewTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerPreviewTemplate(templateId, messageType, getPreviewTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerPreviewTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mNotificationControllerUpdateTemplate(templateId: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mNotificationControllerUpdateTemplate(templateId, updateTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationModuleApi.mNotificationControllerUpdateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationModuleApi - factory interface
 * @export
 */
export const NotificationModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationModuleApiFp(configuration)
    return {
        /**
         * Notifications
         * @summary 
         * @param {string} applicationId 
         * @param {CreateNotificationDto} createNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerCreateNotification(applicationId: string, createNotificationDto: CreateNotificationDto, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.mNotificationControllerCreateNotification(applicationId, createNotificationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Templates
         * @summary 
         * @param {CreateTemplateDto} createTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerCreateTemplate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.mNotificationControllerCreateTemplate(createTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerDeleteTemplate(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.mNotificationControllerDeleteTemplate(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<Notification>> {
            return localVarFp.mNotificationControllerFindAllNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByApplicationId(applicationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Notification>> {
            return localVarFp.mNotificationControllerFindAllNotificationsByApplicationId(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} notificationCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Notification>> {
            return localVarFp.mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllNotificationsByTemplateId(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Notification>> {
            return localVarFp.mNotificationControllerFindAllNotificationsByTemplateId(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [templateName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindAllTemplatesPaginated(page?: number, perPage?: number, templateName?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfTemplate> {
            return localVarFp.mNotificationControllerFindAllTemplatesPaginated(page, perPage, templateName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindOneNotification(notificationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.mNotificationControllerFindOneNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerFindOneTemplate(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.mNotificationControllerFindOneTemplate(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerGetNotificationsForUserById(userId: string, notificationId: number, options?: RawAxiosRequestConfig): AxiosPromise<OutputNotificationWithCompiledMessageAndNotificationTaskDto> {
            return localVarFp.mNotificationControllerGetNotificationsForUserById(userId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerGetPaginatedNotificationsByUserId(userId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseOfOutputNotificationWithCompiledMessageAndNotificationTaskDto> {
            return localVarFp.mNotificationControllerGetPaginatedNotificationsByUserId(userId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {MNotificationControllerPreviewTemplateMessageTypeEnum} messageType 
         * @param {GetPreviewTemplateDto} getPreviewTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerPreviewTemplate(templateId: string, messageType: MNotificationControllerPreviewTemplateMessageTypeEnum, getPreviewTemplateDto: GetPreviewTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.mNotificationControllerPreviewTemplate(templateId, messageType, getPreviewTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateTemplateDto} updateTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mNotificationControllerUpdateTemplate(templateId: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<Template> {
            return localVarFp.mNotificationControllerUpdateTemplate(templateId, updateTemplateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationModuleApi - object-oriented interface
 * @export
 * @class NotificationModuleApi
 * @extends {BaseAPI}
 */
export class NotificationModuleApi extends BaseAPI {
    /**
     * Notifications
     * @summary 
     * @param {string} applicationId 
     * @param {CreateNotificationDto} createNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerCreateNotification(applicationId: string, createNotificationDto: CreateNotificationDto, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerCreateNotification(applicationId, createNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Templates
     * @summary 
     * @param {CreateTemplateDto} createTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerCreateTemplate(createTemplateDto: CreateTemplateDto, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerCreateTemplate(createTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerDeleteTemplate(templateId: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerDeleteTemplate(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindAllNotifications(options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindAllNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindAllNotificationsByApplicationId(applicationId: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindAllNotificationsByApplicationId(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} notificationCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindAllNotificationsByNotificationCategoryId(notificationCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindAllNotificationsByTemplateId(templateId: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindAllNotificationsByTemplateId(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [templateName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindAllTemplatesPaginated(page?: number, perPage?: number, templateName?: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindAllTemplatesPaginated(page, perPage, templateName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindOneNotification(notificationId: number, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindOneNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerFindOneTemplate(templateId: string, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerFindOneTemplate(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerGetNotificationsForUserById(userId: string, notificationId: number, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerGetNotificationsForUserById(userId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerGetPaginatedNotificationsByUserId(userId: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerGetPaginatedNotificationsByUserId(userId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {MNotificationControllerPreviewTemplateMessageTypeEnum} messageType 
     * @param {GetPreviewTemplateDto} getPreviewTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerPreviewTemplate(templateId: string, messageType: MNotificationControllerPreviewTemplateMessageTypeEnum, getPreviewTemplateDto: GetPreviewTemplateDto, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerPreviewTemplate(templateId, messageType, getPreviewTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} templateId 
     * @param {UpdateTemplateDto} updateTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationModuleApi
     */
    public mNotificationControllerUpdateTemplate(templateId: string, updateTemplateDto: UpdateTemplateDto, options?: RawAxiosRequestConfig) {
        return NotificationModuleApiFp(this.configuration).mNotificationControllerUpdateTemplate(templateId, updateTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MNotificationControllerPreviewTemplateMessageTypeEnum = {
    Html: 'HTML',
    Markdown: 'MARKDOWN',
    Text: 'TEXT'
} as const;
export type MNotificationControllerPreviewTemplateMessageTypeEnum = typeof MNotificationControllerPreviewTemplateMessageTypeEnum[keyof typeof MNotificationControllerPreviewTemplateMessageTypeEnum];


/**
 * UserModuleApi - axios parameter creator
 * @export
 */
export const UserModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerCreateNewOtpChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerCreateNewOtp: async (userId: string, channelType: MUserControllerCreateNewOtpChannelTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerCreateNewOtp', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerCreateNewOtp', 'channelType', channelType)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/accounts/otp`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerCreateUser: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('mUserControllerCreateUser', 'createUserDto', createUserDto)
            const localVarPath = `/m-user/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUserAccountsByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerFindAllUserAccountsByUserId', 'userId', userId)
            const localVarPath = `/m-user/users/{userId}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUserPreferencesByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerFindAllUserPreferencesByUserId', 'userId', userId)
            const localVarPath = `/m-user/users/{userId}/user-preferences`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/m-user/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindOneUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerFindOneUser', 'userId', userId)
            const localVarPath = `/m-user/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerRemoveAccountChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerRemoveAccount: async (userId: string, channelType: MUserControllerRemoveAccountChannelTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerRemoveAccount', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerRemoveAccount', 'channelType', channelType)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerUpdateManyUserPreferencesChannelTypeEnum} channelType 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpdateManyUserPreferences: async (userId: string, channelType: MUserControllerUpdateManyUserPreferencesChannelTypeEnum, upsertUserPreferenceDto: UpsertUserPreferenceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerUpdateManyUserPreferences', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerUpdateManyUserPreferences', 'channelType', channelType)
            // verify required parameter 'upsertUserPreferenceDto' is not null or undefined
            assertParamExists('mUserControllerUpdateManyUserPreferences', 'upsertUserPreferenceDto', upsertUserPreferenceDto)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/user-preferences`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertUserPreferenceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accounts
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertAccountChannelTypeEnum} channelType 
         * @param {UpsertAccountDto} upsertAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpsertAccount: async (userId: string, channelType: MUserControllerUpsertAccountChannelTypeEnum, upsertAccountDto: UpsertAccountDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerUpsertAccount', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerUpsertAccount', 'channelType', channelType)
            // verify required parameter 'upsertAccountDto' is not null or undefined
            assertParamExists('mUserControllerUpsertAccount', 'upsertAccountDto', upsertAccountDto)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertAccountDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Preferences
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertUserPreferenceChannelTypeEnum} channelType 
         * @param {string} notificationCategoryId 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpsertUserPreference: async (userId: string, channelType: MUserControllerUpsertUserPreferenceChannelTypeEnum, notificationCategoryId: string, upsertUserPreferenceDto: UpsertUserPreferenceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerUpsertUserPreference', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerUpsertUserPreference', 'channelType', channelType)
            // verify required parameter 'notificationCategoryId' is not null or undefined
            assertParamExists('mUserControllerUpsertUserPreference', 'notificationCategoryId', notificationCategoryId)
            // verify required parameter 'upsertUserPreferenceDto' is not null or undefined
            assertParamExists('mUserControllerUpsertUserPreference', 'upsertUserPreferenceDto', upsertUserPreferenceDto)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/notification-categories/{notificationCategoryId}/user-preferences`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)))
                .replace(`{${"notificationCategoryId"}}`, encodeURIComponent(String(notificationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertUserPreferenceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerVerifyAccountChannelTypeEnum} channelType 
         * @param {VerifyUserDto} verifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerVerifyAccount: async (userId: string, channelType: MUserControllerVerifyAccountChannelTypeEnum, verifyUserDto: VerifyUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('mUserControllerVerifyAccount', 'userId', userId)
            // verify required parameter 'channelType' is not null or undefined
            assertParamExists('mUserControllerVerifyAccount', 'channelType', channelType)
            // verify required parameter 'verifyUserDto' is not null or undefined
            assertParamExists('mUserControllerVerifyAccount', 'verifyUserDto', verifyUserDto)
            const localVarPath = `/m-user/users/{userId}/channel/{channelType}/accounts/verify`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"channelType"}}`, encodeURIComponent(String(channelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Access_Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserModuleApi - functional programming interface
 * @export
 */
export const UserModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerCreateNewOtpChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerCreateNewOtp(userId: string, channelType: MUserControllerCreateNewOtpChannelTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerCreateNewOtp(userId, channelType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerCreateNewOtp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerCreateUser(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerCreateUser(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerFindAllUserAccountsByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerFindAllUserAccountsByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerFindAllUserAccountsByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerFindAllUserPreferencesByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPreference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerFindAllUserPreferencesByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerFindAllUserPreferencesByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerFindAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerFindAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerFindAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerFindOneUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerFindOneUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerFindOneUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerRemoveAccountChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerRemoveAccount(userId: string, channelType: MUserControllerRemoveAccountChannelTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerRemoveAccount(userId, channelType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerRemoveAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerUpdateManyUserPreferencesChannelTypeEnum} channelType 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerUpdateManyUserPreferences(userId: string, channelType: MUserControllerUpdateManyUserPreferencesChannelTypeEnum, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerUpdateManyUserPreferences(userId, channelType, upsertUserPreferenceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerUpdateManyUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accounts
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertAccountChannelTypeEnum} channelType 
         * @param {UpsertAccountDto} upsertAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerUpsertAccount(userId: string, channelType: MUserControllerUpsertAccountChannelTypeEnum, upsertAccountDto: UpsertAccountDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerUpsertAccount(userId, channelType, upsertAccountDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerUpsertAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User Preferences
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertUserPreferenceChannelTypeEnum} channelType 
         * @param {string} notificationCategoryId 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerUpsertUserPreference(userId: string, channelType: MUserControllerUpsertUserPreferenceChannelTypeEnum, notificationCategoryId: string, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerUpsertUserPreference(userId, channelType, notificationCategoryId, upsertUserPreferenceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerUpsertUserPreference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerVerifyAccountChannelTypeEnum} channelType 
         * @param {VerifyUserDto} verifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mUserControllerVerifyAccount(userId: string, channelType: MUserControllerVerifyAccountChannelTypeEnum, verifyUserDto: VerifyUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mUserControllerVerifyAccount(userId, channelType, verifyUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserModuleApi.mUserControllerVerifyAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserModuleApi - factory interface
 * @export
 */
export const UserModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserModuleApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerCreateNewOtpChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerCreateNewOtp(userId: string, channelType: MUserControllerCreateNewOtpChannelTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.mUserControllerCreateNewOtp(userId, channelType, options).then((request) => request(axios, basePath));
        },
        /**
         * Users
         * @summary 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerCreateUser(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.mUserControllerCreateUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUserAccountsByUserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Account>> {
            return localVarFp.mUserControllerFindAllUserAccountsByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUserPreferencesByUserId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserPreference>> {
            return localVarFp.mUserControllerFindAllUserPreferencesByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.mUserControllerFindAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerFindOneUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.mUserControllerFindOneUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerRemoveAccountChannelTypeEnum} channelType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerRemoveAccount(userId: string, channelType: MUserControllerRemoveAccountChannelTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.mUserControllerRemoveAccount(userId, channelType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerUpdateManyUserPreferencesChannelTypeEnum} channelType 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpdateManyUserPreferences(userId: string, channelType: MUserControllerUpdateManyUserPreferencesChannelTypeEnum, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.mUserControllerUpdateManyUserPreferences(userId, channelType, upsertUserPreferenceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Accounts
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertAccountChannelTypeEnum} channelType 
         * @param {UpsertAccountDto} upsertAccountDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpsertAccount(userId: string, channelType: MUserControllerUpsertAccountChannelTypeEnum, upsertAccountDto: UpsertAccountDto, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.mUserControllerUpsertAccount(userId, channelType, upsertAccountDto, options).then((request) => request(axios, basePath));
        },
        /**
         * User Preferences
         * @summary 
         * @param {string} userId 
         * @param {MUserControllerUpsertUserPreferenceChannelTypeEnum} channelType 
         * @param {string} notificationCategoryId 
         * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerUpsertUserPreference(userId: string, channelType: MUserControllerUpsertUserPreferenceChannelTypeEnum, notificationCategoryId: string, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig): AxiosPromise<UserPreference> {
            return localVarFp.mUserControllerUpsertUserPreference(userId, channelType, notificationCategoryId, upsertUserPreferenceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {MUserControllerVerifyAccountChannelTypeEnum} channelType 
         * @param {VerifyUserDto} verifyUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mUserControllerVerifyAccount(userId: string, channelType: MUserControllerVerifyAccountChannelTypeEnum, verifyUserDto: VerifyUserDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.mUserControllerVerifyAccount(userId, channelType, verifyUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserModuleApi - object-oriented interface
 * @export
 * @class UserModuleApi
 * @extends {BaseAPI}
 */
export class UserModuleApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {MUserControllerCreateNewOtpChannelTypeEnum} channelType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerCreateNewOtp(userId: string, channelType: MUserControllerCreateNewOtpChannelTypeEnum, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerCreateNewOtp(userId, channelType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users
     * @summary 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerCreateUser(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerCreateUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerFindAllUserAccountsByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerFindAllUserAccountsByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerFindAllUserPreferencesByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerFindAllUserPreferencesByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerFindAllUsers(options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerFindAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerFindOneUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerFindOneUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {MUserControllerRemoveAccountChannelTypeEnum} channelType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerRemoveAccount(userId: string, channelType: MUserControllerRemoveAccountChannelTypeEnum, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerRemoveAccount(userId, channelType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {MUserControllerUpdateManyUserPreferencesChannelTypeEnum} channelType 
     * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerUpdateManyUserPreferences(userId: string, channelType: MUserControllerUpdateManyUserPreferencesChannelTypeEnum, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerUpdateManyUserPreferences(userId, channelType, upsertUserPreferenceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accounts
     * @summary 
     * @param {string} userId 
     * @param {MUserControllerUpsertAccountChannelTypeEnum} channelType 
     * @param {UpsertAccountDto} upsertAccountDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerUpsertAccount(userId: string, channelType: MUserControllerUpsertAccountChannelTypeEnum, upsertAccountDto: UpsertAccountDto, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerUpsertAccount(userId, channelType, upsertAccountDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Preferences
     * @summary 
     * @param {string} userId 
     * @param {MUserControllerUpsertUserPreferenceChannelTypeEnum} channelType 
     * @param {string} notificationCategoryId 
     * @param {UpsertUserPreferenceDto} upsertUserPreferenceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerUpsertUserPreference(userId: string, channelType: MUserControllerUpsertUserPreferenceChannelTypeEnum, notificationCategoryId: string, upsertUserPreferenceDto: UpsertUserPreferenceDto, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerUpsertUserPreference(userId, channelType, notificationCategoryId, upsertUserPreferenceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {MUserControllerVerifyAccountChannelTypeEnum} channelType 
     * @param {VerifyUserDto} verifyUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModuleApi
     */
    public mUserControllerVerifyAccount(userId: string, channelType: MUserControllerVerifyAccountChannelTypeEnum, verifyUserDto: VerifyUserDto, options?: RawAxiosRequestConfig) {
        return UserModuleApiFp(this.configuration).mUserControllerVerifyAccount(userId, channelType, verifyUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MUserControllerCreateNewOtpChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerCreateNewOtpChannelTypeEnum = typeof MUserControllerCreateNewOtpChannelTypeEnum[keyof typeof MUserControllerCreateNewOtpChannelTypeEnum];
/**
 * @export
 */
export const MUserControllerRemoveAccountChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerRemoveAccountChannelTypeEnum = typeof MUserControllerRemoveAccountChannelTypeEnum[keyof typeof MUserControllerRemoveAccountChannelTypeEnum];
/**
 * @export
 */
export const MUserControllerUpdateManyUserPreferencesChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerUpdateManyUserPreferencesChannelTypeEnum = typeof MUserControllerUpdateManyUserPreferencesChannelTypeEnum[keyof typeof MUserControllerUpdateManyUserPreferencesChannelTypeEnum];
/**
 * @export
 */
export const MUserControllerUpsertAccountChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerUpsertAccountChannelTypeEnum = typeof MUserControllerUpsertAccountChannelTypeEnum[keyof typeof MUserControllerUpsertAccountChannelTypeEnum];
/**
 * @export
 */
export const MUserControllerUpsertUserPreferenceChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerUpsertUserPreferenceChannelTypeEnum = typeof MUserControllerUpsertUserPreferenceChannelTypeEnum[keyof typeof MUserControllerUpsertUserPreferenceChannelTypeEnum];
/**
 * @export
 */
export const MUserControllerVerifyAccountChannelTypeEnum = {
    Email: 'EMAIL',
    Sms: 'SMS',
    WebPush: 'WEB_PUSH',
    Slack: 'SLACK'
} as const;
export type MUserControllerVerifyAccountChannelTypeEnum = typeof MUserControllerVerifyAccountChannelTypeEnum[keyof typeof MUserControllerVerifyAccountChannelTypeEnum];


